
对于JavaScript这样单线程的东西唯一的解耦方法就是提供异步API。
异步API，简单的说：不会立即执行的方法。

> setTimeout 与setInterval

- 如果回调的执行时间大于间隔时间，那么浏览器会继续执行它们，导致真正的间隔时间比原来的大一点.
- 它们存在一个最小的时钟间隔，在IE6~IE8中为15.6ms，后来精准到10ms，IE10为4ms，其它浏览器相仿.
- 有关零秒延迟，此回调将会放到一个能立即执行的时段进行触发，JavaScript代码大体上自顶向下执行，但中间穿插着有关DOM渲染，事件回应等异步代码它们将组成一个队列，零秒延迟将会实现插队操作
- 不写第二个参数，浏览器自动配时间，在IE，FireFox中，第一次可能给个很大数字，100ms上下，往后会缩小到最小时间间隔，Safari,Chrome,Opera则多为10ms上下，FireFox中，setInterval不写第二个参数，会当作setTimeout处理，只执行一次。
- 支持额外参数，从第三个参数起，作为回调的传参传入
- setTimeout方法的时间参数若为极端值（如负数，0，或者极大的正数），会立即执行。

**算出最小间隔时间**
```
function test (count, ms) {
	var c = 1
	var time = [new Date() * 1]
	var id = setTimeout(() => {
		time.push(new Date() * 1)
		c += 1
		if (c <= count) {
			setTimeout(arguments.callee, ms)
		} else {
			clearTimeout(id)
			var t1 = time.length
			var av1 = 0
			for (var i = 1; i < t1; i++) {
				var n = time[i] - time[i - 1] // 收集每次与上一次相差的时间数
				av1 += n
			}
			console.log(av1 / count) // 求平均值
		}
	}, ms)
}

window.onload = () => {
	var id = setTimeout(() => {
		test(100, 1)
		clearTimeout(id)
	}, 3000)
}
```

如果闲最短时间间隔太大，可以改造一下setTimeout。
方法：利用image死链时立即执行onerror回调的情况进行改造。

```
var orig_setTimeout = window.setTimeout
window.setTimeout = function (fun, wait) {
	if (wait < 15) {
		orig_setTimeout(fun, wait)
	} else {
		var img = new Image()
		img.onload = image.onerror = function () {
			fun()
		}
		img.src = "data:,foo"
	}
}
```

> Deferred

是一个双链参数加工的流水线模型。双链是指它内部把回调分成两种，一种叫成功回调，用于正常的执行，一种叫错误回调，用于出错时执行。各自组成两个队列

添加回调时是一组组添加的，每组回调的参数都是上一组回调的处理结果，当然只有第一组的参数是用户传入的。

流水线的解释，每个回调可能不是紧挨着执行，有时需要耗些时间，可能是异步API引起的，也可能是调用了如`wait`这样的方法。假若出错，由后一组的错误回调捕获处理，没有问题尝试再转回成功队列。

```
var Deferred = function (canceller) {
	this.chain = []
	this.id = setTimeout('1')
	this.fired = -1
	this.paused = 0
	this.canceller = canceller
	this.silentlyCancelled = false
	this.chained = false
}

function curry (fn, scope, args) {
	return function () {
		var argsv = [].concat.apply(args, arguments)
		return fn.apply(scope, argsv)
	}
} 

Deferred.prototype = {
	// 3种状态，未触发，触发成功，触发失败
	state: function () {
		if (this.fired === -1) { // 未触发
			return 'unfired'
		} else if (this.fired === 0) { // 触发成功
			return 'sucess'
		} else { // 触发失败
			retur 'error'
		}
	},

	// 取消触发，类似于ajax的abort
	cancel: function (e) {
		if (this.fired === -1) { // 只有未触发时才能cancel掉
			if (this.canceller) {
				this.canceller(this)
			} else {
				this.silentlyCancelled = ture
			}
			if (this.fired === -1) {
				if (!(e instanceof Error)) {
					e = new Error(e + '')
				}
				this.errback(e)
			}
		} else if ((this.fired === 0) && (this.results[0] instaceof Deferred)) {
			this.results[0].cancel(e)
		}
	},

	// 决定是用那个队列 
	_resback: function (res) {
		this.fired = ((res instanceof Error) ? 1 : 0)
		this.results[this.fired] = res
		if (this.paused === 0) {
			this._fire()
		}
	},

	// 判断是否触发过
	_check: function () {
		if (this.fired != -1) {
			if (!this.silentlyCancelled) {
				throw new '此方法已经被调用过！'
			}
			this.silentlyCancelled = false
			return
		}
	},

	// 触发成功队列
	callback: function (res) {
		this._check()
		if (res instanceof Deferred) {
			throw new Error('Deferred instances can only be chained if they are the result of a callback')
		}
		this._resback(res)
	},

	// 触发错误队列
	errback: function (res) {
		this._check()
		if (res instanceof Deferred) {
			throw new Error('Deferred instances can only be chained if they are the result of a ballback')
		}
		if (!(res instanceof Error)) {
			res = new Error(res + '')
		}
		this._resback(res)
	},

	// 同时添加成功与错误回调
	addBoth: function (a, b) {
		b = b || a
		return this.addCallbacks(a, b)
	},

	// 添加成功回调
	addCallback: function (fn) {
		if (argynebts.length > 1) {
			var args = [].slice.call(argumnets, 1)
			fn = curry(fn, window, args)
		}
		return this.addCallbacks(fn, null)
	},

	// 添加错误回调
	addErrback: function (fn) {
		if (arguments.length > 1) {
			var args = [].slice.call(arguments, 1)
			fn = curry(fn, window,argus)
		}
		return this.addCallbacks(null, fn)
	},

	// 同时添加成功回调与错误回调，后来Promise的then方法就是参考它设计
	addCallbacks: function (cb, eb) {
		if (this.chained) {
			throw new Error('Chained Deferreds can not be re-used')
		}
		if (this.finalized) {
			throw new Error('Finalized Deferreds can not be re-used')
		}
		this.chain.push([cb, eb])
		if (this.fired >= 0) {
			this._fire()
		}
		return this
	},

	// 将队列的回调依次触发
	_fire: function () {
		var chain = this.chain
		var fired = this.fired
		var res = this.results(fired)
		var self = this
		var cb = null
	}

}
```


> JS Deferred

`JS Deferred`实现形态基本奠定了后来成为`Promise/A`的范式

每一个回调都至少涉及一个`Deferred`

github源码：[jsdeferred](https://github.com/cho45/jsdeferred/blob/master/jsdeferred.js)




