
对于JavaScript这样单线程的东西唯一的解耦方法就是提供异步API。
异步API，简单的说：不会立即执行的方法。

> setTimeout 与setInterval

- 如果回调的执行时间大于间隔时间，那么浏览器会继续执行它们，导致真正的间隔时间比原来的大一点.
- 它们存在一个最小的时钟间隔，在IE6~IE8中为15.6ms，后来精准到10ms，IE10为4ms，其它浏览器相仿.
- 有关零秒延迟，此回调将会放到一个能立即执行的时段进行触发，JavaScript代码大体上自顶向下执行，但中间穿插着有关DOM渲染，事件回应等异步代码它们将组成一个队列，零秒延迟将会实现插队操作
- 不写第二个参数，浏览器自动配时间，在IE，FireFox中，第一次可能给个很大数字，100ms上下，往后会缩小到最小时间间隔，Safari,Chrome,Opera则多为10ms上下，FireFox中，setInterval不写第二个参数，会当作setTimeout处理，只执行一次。
- 支持额外参数，从第三个参数起，作为回调的传参传入
- setTimeout方法的时间参数若为极端值（如负数，0，或者极大的正数），会立即执行。

**算出最小间隔时间**
```
function test (count, ms) {
	var c = 1
	var time = [new Date() * 1]
	var id = setTimeout(() => {
		time.push(new Date() * 1)
		c += 1
		if (c <= count) {
			setTimeout(arguments.callee, ms)
		} else {
			clearTimeout(id)
			var t1 = time.length
			var av1 = 0
			for (var i = 1; i < t1; i++) {
				var n = time[i] - time[i - 1] // 收集每次与上一次相差的时间数
				av1 += n
			}
			console.log(av1 / count) // 求平均值
		}
	}, ms)
}

window.onload = () => {
	var id = setTimeout(() => {
		test(100, 1)
		clearTimeout(id)
	}, 3000)
}
```

如果闲最短时间间隔太大，可以改造一下setTimeout。
方法：利用image死链时立即执行onerror回调的情况进行改造。

```
var orig_setTimeout = window.setTimeout
window.setTimeout = function (fun, wait) {
	if (wait < 15) {
		orig_setTimeout(fun, wait)
	} else {
		var img = new Image()
		img.onload = image.onerror = function () {
			fun()
		}
		img.src = "data:,foo"
	}
}
```

> Deferred

是一个双链参数加工的流水线模型。双链是指它内部把回调分成两种，一种叫成功回调，用于正常的执行，一种叫错误回调，用于出错时执行。各自组成两个队列

添加回调时是一组组添加的，每组回调的参数都是上一组回调的处理结果，当然只有第一组的参数是用户传入的。

流水线的解释，每个回调可能不是紧挨着执行，有时需要耗些时间，可能是异步API引起的，也可能是调用了如`wait`这样的方法。假若出错，由后一组的错误回调捕获处理，没有问题尝试再转回成功队列。

```
var Deferred = function (canceller) {
	this.chain = []
	this.id = setTimeout('1')
	this.fired = -1
	this.paused = 0
	this.canceller = canceller
	this.silentlyCancelled = false
	this.chained = false
}

function curry (fn, scope, args) {
	return function () {
		var argsv = [].concat.apply(args, arguments)
		return fn.apply(scope, argsv)
	}
} 

Deferred.prototype = {
	// 3种状态，未触发，触发成功，触发失败
	state: function () {
		if (this.fired === -1) { // 未触发
			return 'unfired'
		} else if (this.fired === 0) { // 触发成功
			return 'sucess'
		} else { // 触发失败
			retur 'error'
		}
	},

	// 取消触发，类似于ajax的abort
	cancel: function (e) {
		if (this.fired === -1) { // 只有未触发时才能cancel掉
			if (this.canceller) {
				this.canceller(this)
			} else {
				this.silentlyCancelled = ture
			}
			if (this.fired === -1) {
				if (!(e instanceof Error)) {
					e = new Error(e + '')
				}
				this.errback(e)
			}
		} else if ((this.fired === 0) && (this.results[0] instaceof Deferred)) {
			this.results[0].cancel(e)
		}
	},

	// 决定是用那个队列 
	_resback: function (res) {
		this.fired = ((res instanceof Error) ? 1 : 0)
		this.results[this.fired] = res
		if (this.paused === 0) {
			this._fire()
		}
	},

	// 判断是否触发过
	_check: function () {
		if (this.fired != -1) {
			if (!this.silentlyCancelled) {
				throw new '此方法已经被调用过！'
			}
			this.silentlyCancelled = false
			return
		}
	},

	// 触发成功队列
	callback: function (res) {
		this._check()
		if (res instanceof Deferred) {
			throw new Error('Deferred instances can only be chained if they are the result of a callback')
		}
		this._resback(res)
	},

	// 触发错误队列
	errback: function (res) {
		this._check()
		if (res instanceof Deferred) {
			throw new Error('Deferred instances can only be chained if they are the result of a ballback')
		}
		if (!(res instanceof Error)) {
			res = new Error(res + '')
		}
		this._resback(res)
	},

	// 同时添加成功与错误回调
	addBoth: function (a, b) {
		b = b || a
		return this.addCallbacks(a, b)
	},

	// 添加成功回调
	addCallback: function (fn) {
		if (argynebts.length > 1) {
			var args = [].slice.call(argumnets, 1)
			fn = curry(fn, window, args)
		}
		return this.addCallbacks(fn, null)
	},

	// 添加错误回调
	addErrback: function (fn) {
		if (arguments.length > 1) {
			var args = [].slice.call(arguments, 1)
			fn = curry(fn, window,argus)
		}
		return this.addCallbacks(null, fn)
	},

	// 同时添加成功回调与错误回调，后来Promise的then方法就是参考它设计
	addCallbacks: function (cb, eb) {
		if (this.chained) {
			throw new Error('Chained Deferreds can not be re-used')
		}
		if (this.finalized) {
			throw new Error('Finalized Deferreds can not be re-used')
		}
		this.chain.push([cb, eb])
		if (this.fired >= 0) {
			this._fire()
		}
		return this
	},

	// 将队列的回调依次触发
	_fire: function () {
		var chain = this.chain
		var fired = this.fired
		var res = this.results(fired)
		var self = this
		var cb = null
		while (chain.length > 0 && this.paused === 0) {
			var pair = chain.shift()
			var f = pair[fired]
			if (f === null) {
				continue
			}
			try {
				res = f(res)
				fired = ((res instanceof Eorror ? 1 : 0))
				if (res instanceof Deferred) {
					cb = function (res) {
						self.paused--
						self_resback(res)
					}
					this.paused++
				}
			} catch (err) {
				fired = 1
				if (!(err instanceof Error)) {
					try {
						err = new Error(err + '')	
					} catch (e) {
						alert(e)
					}
				}
				res = err
			}
		}
		this.fired = fired
		this.result[fired] = res
		if (cb && this.paused) {
			res.addBoth(cb)
			res.chained = true
		}
	}
}
```
触发这些回调时通过`callback`,与`ertback`方法，通常放到`XMLHttpRequres`对象的回调中执行它们。查看`XMLHttpRequeset`的`status`(状态码)，即便是成功返回还是服务器错误，决定调用`Deferred`对象的`callback`还是`ertback`,将返回值传入到它们里面


> JS Deferred

`JS Deferred`实现形态基本奠定了后来成为`Promise/A`的范式

每一个回调都至少涉及一个`Deferred`

github源码：[jsdeferred](https://github.com/cho45/jsdeferred/blob/master/jsdeferred.js)

```
function Deferred () {
	return (this instanceof Deferred) ? this.init() : new Deferred()
}
Deferred.ok = function (x) {
	return x
}
Deferred.ng = function (x) {
	throw x
}

Deferred.wait = function (n) {
	var d = new Deferred()
	var t = new Date()
	var id = setTImeout(function () {
		d.call((new Date()).getTime() - t.getTime())
	}, n * 1000)
	d.canceller = function () {
		clearTimeout(id)
	}
	return d
}

Deferred.register = function (name, fun) {
	this.prototype[name] = function () {
		var a = arguments
		return this.next(fcuntion () {
			return fun.apply(this, a)
		})
	}
}

Deferred.parallel = function (dl) {
	var isArray = false // 它可以放一个数组或对象，或N个函数，或Deferred对象做参数
	if (arguments.length > 1) {
		dl = Array.prototype.slice.call(arguments)
		isArray = true
	} else if (Array.isArray && Array.isArray(dl) || typeof dl.length === 'number') {
		isArray = true
	}
}

Deferred.register('wait', Deferred.wait)

Deferred.prototype = {
	init: function () {
		this._next = null
		this.callback = {
			ok: Deferred.ok
			ng: Deferred.ng
		}
		return this
	},

	next: function (fun) {
		return this._post('ok', fun)
	},

	error: function (fun) {
		return this._post('ng', fun)
	},

	call: function (val) {
		return this._fire('ok', val)
	},

	fail: function (err) {
		return this._fire('ng', err)
	},

	cancel: function () {
		(this.canceller || function () {})()
		return this.init()
	},

	_post: function (okng, fun) {
		this._next = new Deferred()
		this._next.callback[okng] = fun
		return this._next
	},

	_fire: function (okng, value) {
		var next = 'ok' // 每次都尝试从成功队列执行
		try { // 决定是ing成功的回调还是错误的回调
			value = this.callback[okng].call(this, value)
		} catch (e) {
			next = 'ng'
			value = e
		} 
		if (value instanceof Deferred) {
			value._next = this._next // 把`_next`对象进行转移，防止它在setTimeout中执行。
		} else { // 执行链表中的下一个Deferred的_fire
			if (this._next) {
				this._next.fire(next, value)
			}
		}
		return this
	}
}
```

**Deferred链的实现**
它每绑定一个回调函数就需要一个全新的`Deferred`对象，从而形成一个`Deferred`链，两个`Deferred`能连到一块，取决于两个东西：
- 当前`Deferred`实例在`_fire`方法执行`callback`时得到的属性
- `_next`属性

**JSDeferred的并归结果**
它里面存在一个数组，用于收集每一个阶段N个并行执行的回调的结果，同时应该还有一个计数器，如果回调都成功执行了开始执行“回调的回调”，这个回调是框架提供的，然后处理所有收集到的结果，放进用户绑定的后续回调中。


