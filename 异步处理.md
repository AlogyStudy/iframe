
对于JavaScript这样单线程的东西唯一的解耦方法就是提供异步API。
异步API，简单的说：不会立即执行的方法。

> setTimeout 与setInterval

- 如果回调的执行时间大于间隔时间，那么浏览器会继续执行它们，导致真正的间隔时间比原来的大一点.
- 它们存在一个最小的时钟间隔，在IE6~IE8中为15.6ms，后来精准到10ms，IE10为4ms，其它浏览器相仿.
- 有关零秒延迟，此回调将会放到一个能立即执行的时段进行触发，JavaScript代码大体上自顶向下执行，但中间穿插着有关DOM渲染，事件回应等异步代码它们将组成一个队列，零秒延迟将会实现插队操作
- 不写第二个参数，浏览器自动配时间，在IE，FireFox中，第一次可能给个很大数字，100ms上下，往后会缩小到最小时间间隔，Safari,Chrome,Opera则多为10ms上下，FireFox中，setInterval不写第二个参数，会当作setTimeout处理，只执行一次。
- 支持额外参数，从第三个参数起，作为回调的传参传入
- setTimeout方法的时间参数若为极端值（如负数，0，或者极大的正数），会立即执行。

**算出最小间隔时间**
```
function test (count, ms) {
	var c = 1
	var time = [new Date() * 1]
	var id = setTimeout(() => {
		time.push(new Date() * 1)
		c += 1
		if (c <= count) {
			setTimeout(arguments.callee, ms)
		} else {
			clearTimeout(id)
			var t1 = time.length
			var av1 = 0
			for (var i = 1; i < t1; i++) {
				var n = time[i] - time[i - 1] // 收集每次与上一次相差的时间数
				av1 += n
			}
			console.log(av1 / count) // 求平均值
		}
	}, ms)
}

window.onload = () => {
	var id = setTimeout(() => {
		test(100, 1)
		clearTimeout(id)
	}, 3000)
}
```

如果闲最短时间间隔太大，可以改造一下setTimeout。
方法：利用image死链时立即执行onerror回调的情况进行改造。

```
var orig_setTimeout = window.setTimeout
window.setTimeout = function (fun, wait) {
	if (wait < 15) {
		orig_setTimeout(fun, wait)
	} else {
		var img = new Image()
		img.onload = image.onerror = function () {
			fun()
		}
		img.src = "data:,foo"
	}
}
```

> Deferred

是一个双链参数加工的流水线模型。双链是指它内部把回调分成两种，一种叫成功回调，用于正常的执行，一种叫错误回调，用于出错时执行。各自组成两个队列

添加回调时是一组组添加的，每组回调的参数都是上一组回调的处理结果，当然只有第一组的参数是用户传入的。

流水线的解释，每个回调可能不是紧挨着执行，有时需要耗些时间，可能是异步API引起的，也可能是调用了如`wait`这样的方法。假若出错，由后一组的错误回调捕获处理，没有问题尝试再转回成功队列。

```
var Deferred = function (canceller) {
	this.chain = []
	this.id = setTimeout('1')
	this.fired = -1
	this.asused = 0
	this.canceller = canceller
	this.silentlyCancelled = false
	this.chained = false
}
```


> JS Deferred

`JS Deferred`实现形态基本奠定了后来成为`Promise/A`的范式

每一个回调都至少涉及一个`Deferred`

github源码：[jsdeferred](https://github.com/cho45/jsdeferred/blob/master/jsdeferred.js)




