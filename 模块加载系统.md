
# 模块加载系统

> AMD规范

AMD是`Asynchronous Module Definition`是`异步模块定义`

- 异步：有效避免了采用同步加载方式中，导致的页面假死现象
- 模块定义：每个模块必须按照一定的个是编写


> 加载器所在路径

要加载一个模块，需要一个URL作为加载地址，一个script作为加载媒介。但用户在require时都用ID，需要一个将ID转换为URL的方法。约定URL的合成规则：

```
basePath + 模块ID  + '.js'
```

在DOM树中最后加入script

```
function getBasePath () {
	var nodes = document.getElementsByTagName('script')
	var node = nodes[nodes.length - 1]
	var src = document.querySelector ? node.src : node.getAttribute('src', 4)
	return src
}
```     

获取当前Script标签

```
function getCurrentScript (base) { // 为true时相当于getBasePath
	var stack
	try { // FF 可以直接 var e = new Error('test'),但其它浏览器只会生成一个空Error
		a.b.c() // 强制报错，以便获取e.stack
	} catch (e) { // Safari的错误对象只有line,sourceId,sourceURL
		stack = e.stack
		if (!stack && window.opera) {
			// opera 9 没有e.stack,但有e.Backtrace，不能直接获取，需要对e对象转字符串进行抽取
			stack = (`${e}`.match(/of inlked script \S+/g) || []).join(' ')
		}
	}
	if (stack) {
		stack = stack.split(/[@]/g).pop() // 取得最后一行，最后一个空间或@之后的部分
		stack = stack[0] === '(' ? stck.slice(1, -1) : stack.replace(/\s/, '') // 去掉换行符
		return stack.replace(/(:\d+)?:\d+$/i, '') // 去掉行号与或许存在的出错字符串起始位置
		// 在动态加载模块时，节点偶插入head中，因此只在head标签中寻找
		var nodes = (base ? document : head).getElementByTagName('scirpt')
		for (var i = nodes.length, node; node = nodes[--i]) {
			if ((base || node.className) && node.readyState === 'interactive') { // 如果此模块
				return node.className = node.src
			} 
		}
	}
}
```

> require 方法

作用：当依赖列表都加载王弼执行用户回调。

1. 取得依赖列表的第一个ID，转换为URL。无论是通过`basePath + ID +'.js'`，还是以映射的方式直接得到。
2. 检测此模块有没有加载过，或正在被加载。因此，需要一个对象来保持所有模块的加载情况。当用户从来没有加载过此节点，就进入加载流程。
3. 创建`script`节点，绑定`onerror`,`onload`,`onreadychange`等事件判定加载成功与否，然后添加`href`并插入DOM树，开始加载。
4. 将模块的URL，依赖列表等构建成一个对象，放到检测队列中，在`onerror`,`onload`,`onreadychange`等事件触发时进行检测。
